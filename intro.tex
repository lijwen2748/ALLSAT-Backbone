\section{Introduction}
The SAT (SATisfiable) applications, such as model checking~\cite{bmc,ic3}, program analysis~\cite{klee,cpachecker,cbmc}, network verification ~\cite{lopes2015checking,majumdar2014kuai,zhang2012verification}, quantifier elimination~\cite{brauer2011existential} and predicate abstraction~\cite{lahiri2003symbolic}, have gained considerable attentions due to the increasing capability of modern SAT solvers. 
Also, among several applications like unbounded hardware model checking ~\cite{car}, logic minimization ~\cite{sapra2003sat}, and temporal logic planning ~\cite{aalta}, computing all satisfiable assignments of the model is demanded. This paper focuses on the ALLSAT (ALL-SATisfiable) problem, which aims to compute all satisfiable assignment of a propositional formula, and presents an efficient solver \tool to help tackle such problem.

Although the satisfiability of propositional formulas is known as a NP-complete problem, modern SAT solvers are able to find a satisfiable assignment within affordable time. However, directly enumerating all satisfiable assignments of a formula may be infeasible because the number of such assignments can be exponential to the size of the formula. As a result, solving the ALLSAT problem remains as a challenging task. As far as we know, there are mainly two kinds of solutions to ALLSAT, i.e., the blocking-based~\cite{mcmillan2002applying} and non-blocking-based~\cite{grumberg2004memory}. The blocking-based strategy uses the SAT solver to find a satisfiable assignment, and then blocks such assignment in the original formula so as to avoid finding the same solution repeatedly. Blocking partial assignments instead of the full ones is a common optimization used in the blocking-based solution. The motivation comes from that the SAT solver normally is good at enumerating partial assignments while not at the full ones. 
Meanwhile, the non-blocking solution backtracks the decision diagram inside the SAT solver to find every satisfiable assignment of the given formula. Once a (full) satisfiable assignment is found by the SAT solver, the non-blocking approach backtracks to a previous decision level with some specific strategies and flip the value of the decision variable at that level to generate a new assignment. The ALLSAT computation is complete as soon as every branch value of variables in the decision diagram is visited. 
The advantages of the non-blocking strategy are to avoid the changes of the formula and utilizes the full information of the decision diagrams in the SAT solver, while the blocking-based one is more straightforward and the implementation does not require changes to the SAT solver.

The ALLSAT solver \tool we introduced is a blocking based solver, we use Minisat v2.1.1~\cite{minisat} as the underlying SAT solver and implemented \tool with C++. The main innovation of \tool is that it uses the backbone information to reduce the length of the partial solutions. Every backbone variable is removed from the partial solution and added to the formula as a unit clause. In this way, \tool gets much shorter partial solutions without changing the correctness of the partial solutions. 
The number of SAT solving in the finding of every solution in \tool is reduced since every single shorter partial solution represents more full solutions. Comparing to the blocking based ALLSAT solvers with different coverage techniques~\cite{jin2005efficient}~\cite{morgado2005good}, \tool generates much shorter partial solutions for most of the formulas. Although finding backbone variables requires additional SAT solving, \tool is still faster than the state-of-the-art tool~\cite{ctool} (\ctool).

We compared \tool with 4 other tools, including 2 blocking based tools, \ctool~\cite{ctool} and \bc, one non-blocking based tool , \nbc and one BDD-based tool, \bdd~\cite{ietool}. Among the 5 tools, \tool solves (finds every solution of the given formulas) the most formulas (79) within the given time and memory limitation, while the number of solved formulas for \ctool, \bc, \nbc and \bdd  are 65, 64, 53 and 50 respectively. 
For the formulas that are solved by both \tool and \ctool, \tool uses 23\% less computing time than \ctool does.
\tool uses 37\%, 68\% and 31\% less computing time than \bc, \nbc and \bdd does respectively for the formulas that are mutually solved by \tool and one of the comparing tools.
\tool also gets the shortest blocking clauses among the three blocking based tools, the average length of blocking clauses for \tool is 1026, which is 20 times less than \ctool (22182) and 84\% less than \bc (6180). 

The remainder of the paper is organized as follows. We describe notations and preliminaries in Section \ref{sec:prel}. The algorithms of \tool are discussed in Section \ref{sec:meth}, experimental results are shown in Section \ref{sec:expr} and related work are discussed in Section \ref{sec:rela}. We conclude the paper in Section \ref{sec:conc}.

