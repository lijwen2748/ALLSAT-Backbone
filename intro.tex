\section{Introduction}
SAT (satisfiable) problems have gained considerable attentions with the power of modern SAT solvers. SAT solvers and SAT problems are widely used in model checking[][], program analysis[][], planning[][], and bioinformatics[][].
In several of the areas that SAT solvers are applied, multiple satisfiable assignments are needed, in some of the applications including unbounded hardware model checking[], testing cases generation[], and temporal logic planning[], finding all of the satisfiable assignments is required. This paper focus on these kind of problems (ALLSAT problems) and proposed a solver \tool to find every satisfiable assignment of a given propositional formula efficiently.

Although finding a satisfiable assignment of a propositional formula is known as a NP problem[], modern SAT solvers are still able to find the satisfiable assignment within an acceptable period of time. But for some of the formulas, directly enumerating every satisfiable assignment of the formula is infeasible due to the exponential number of satisfiable assignments. Therefore, finding all satisfiable assignments of the given formula remains challenging.

To overcome these challenges, there are mainly two kinds of strategies, blocking based strategies[], and non-blocking strategies[]. Blocking based strategies uses SAT solver to find a satisfiable assignment (solution), and adds the blocking clause generated from the solution to avoid finding the same solution again. Partial solutions are computed during the blocking clause generation, a partial solution is a subset of a solution, every clause in the given clause are still satisfied by a partial solution. For some of the cases that the solver is efficient to enumerate all the partial solutions while it is too much for the solver to enumerate all the satisfiable assignments directly. 
Non-Blocking strategies backtracks with the decision tree to find every satisfiable assignment of the given formula. Whenever a model if found by the SAT solver, non-blocking strategies backtrack to a previous decision level based on the some strategies and change the assignment of the decision variable in that level to generate a new solution. When every branch in the decision tree is visited, ALLSAT computing of the formula is finished. Comparing to blocking based strategies, non-blocking strategies avoid the change in the formula and use the complete information of the decision trees in the SAT solvers. 

The ALLSAT solver \tool we introduced is a blocking based solver, we use Minisat[] v2.1.1 as the underlying SAT solver and implemented \tool with C++. The main difference between \tool and other existing tools is that \tool uses the backbone information to reduce the length of the partial solutions. Comparing to the  blocking based ALLSAT solvers with different coverage techniques[][], \tool generates shorter partial solutions for most of the formulas. \tool uses a on-the-fly technique to compute backbone variables and multiple solutions at the same time, a backbone variable is added to the original formula and removed from all partial solution as soon as it is found. Although finding backbone variables requires additional SAT solving, \tool is still faster than the state-of-the-art tool[] (\ctool).

We compared to \tool with 2 blocking based strategies, \ctool[] and \bc[], one non-blocking based strategy, \nbc[] and one BDD-based strategy, \bdd[], results show that \tool finished (found all solutions of the given formula) the most formula among all the tools within the given time limitation. And for the formulas that all of the 4 tools are able to finish, \tool has the least average computing time.

The remainder of the paper is organized as follows. We describe notation and preliminaries in Section \ref{sec:prel}. The algorithms of \tool are discussed in Section \ref{sec:meth}, experimental methodology and results are shown in Section \ref{sec:expr} and related work are discussed in Section \ref{sec:rela}. We conclude the paper in Section \ref{sec:conc}.

