\section{Introduction}
SAT (satisfiable) problems have gained considerable attentions because the power of modern SAT solvers. SAT solvers and SAT problems are widely used in model checking~\cite{bmc}~\cite{ic3}, program analysis~\cite{klee}~\cite{cpachecker}~\cite{cbmc}, network verification ~\cite{lopes2015checking}~\cite{majumdar2014kuai}~\cite{zhang2012verification}, quantifier elimination~\cite{brauer2011existential}, and predicate abstraction~\cite{lahiri2003symbolic}.
In several of the areas that SAT solvers are applied, multiple satisfiable assignments are needed, in some of the applications including unbounded hardware model checking ~\cite{car}, logic minimization ~\cite{sapra2003sat}, and temporal logic planning ~\cite{aalta}, finding every satisfiable assignment is required. This paper focus on these kind of problems (ALLSAT problems) and proposed a solver \tool to find every satisfiable assignment of a given propositional formula efficiently.

Although finding a satisfiable assignment of a propositional formula is known as a NP problem, modern SAT solvers are still able to find the satisfiable assignment within an acceptable period of time. But for some of the formulas, directly enumerating every satisfiable assignment of the formula is infeasible due to the exponential number of satisfiable assignments. Therefore, finding all satisfiable assignments of the given formula remains challenging.
To overcome these challenges, there are mainly two kinds of strategies, blocking based strategies~\cite{mcmillan2002applying}, and non-blocking strategies ~\cite{grumberg2004memory}. Blocking based strategies uses SAT solver to find a solution, and adds the blocking clauses generated from the solution back to the original formula in order to avoid finding the same solution again. Computing the partial solution is a common technique used in blocking based strategies. For some of the cases that the SAT solver is efficient to enumerate every partial solution while fails to enumerate every individual full solution efficiently. 
Non-blocking strategies backtracks with the decision tree to find every satisfiable assignment of the given formula. Whenever a solution if found by the SAT solver, non-blocking strategies backtrack to a previous decision level based on the some strategies and change the assignment of the decision variable at that level to generate a new solution. When every branch in the decision tree is visited, ALLSAT computing of the formula is finished. 
Comparing to blocking based strategies, non-blocking strategies avoid the changes in the formula and use the complete information of the decision trees in the SAT solvers, while the idea of the blocking based strategies are more straightforward, and the implementations of blocking based strategies do not require changes to SAT solvers.

The ALLSAT solver \tool we introduced is a blocking based solver, we use Minisat v2.1.1~\cite{minisat} as the underlying SAT solver and implemented \tool with C++. The main innovation of \tool is that it uses the backbone information to reduce the length of the partial solutions. Every backbone variable is removed from the partial solution and added to the formula as a unit clause. In this way, \tool gets much shorter partial solutions without changing the correctness of the partial solutions. 
The number of SAT solving in the finding of every solution in \tool is reduced since every single shorter partial solution represents more full solutions. Comparing to the blocking based ALLSAT solvers with different coverage techniques~\cite{jin2005efficient}~\cite{morgado2005good}, \tool generates much shorter partial solutions for most of the formulas. Although finding backbone variables requires additional SAT solving, \tool is still faster than the state-of-the-art tool~\cite{ctool} (\ctool).

We compared \tool with 4 other tools, including 2 blocking based tools, \ctool~\cite{ctool} and \bc, one non-blocking based tool , \nbc and one BDD-based tool, \bdd~\cite{ietool}. Among the 5 tools, \tool solves (finds every solution of the given formulas) the most formulas (79) within the given time and memory limitation, while the number of solved formulas for \ctool, \bc, \nbc and \bdd  are 65, 64, 53 and 50 respectively. 
For the formulas that are solved by both \tool and \ctool, \tool uses 23\% less computing time than \ctool does.
\tool uses 37\%, 68\% and 31\% less computing time than \bc, \nbc and \bdd does respectively for the formulas that are mutually solved by \tool and one of the comparing tools.
\tool also gets the shortest blocking clauses among the three blocking based tools, the average length of blocking clauses for \tool is 1026, which is 20 times less than \ctool (22182) and 84\% less than \bc (6180). 

The remainder of the paper is organized as follows. We describe notations and preliminaries in Section \ref{sec:prel}. The algorithms of \tool are discussed in Section \ref{sec:meth}, experimental results are shown in Section \ref{sec:expr} and related work are discussed in Section \ref{sec:rela}. We conclude the paper in Section \ref{sec:conc}.

