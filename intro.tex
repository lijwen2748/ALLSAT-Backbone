\section{Introduction}
The SAT (SATisfiable) applications, such as model checking~\cite{bmc,ic3}, program analysis~\cite{klee,cpachecker,cbmc}, network verification ~\cite{lopes2015checking,majumdar2014kuai,zhang2012verification}, quantifier elimination~\cite{brauer2011existential} and predicate abstraction~\cite{lahiri2003symbolic}, have gained considerable attentions due to the increasing capability of modern SAT solvers. 
Also, among several applications like unbounded hardware model checking ~\cite{car}, logic minimization ~\cite{sapra2003sat}, and temporal logic planning ~\cite{aalta}, computing all satisfiable assignments of the model is demanded. This paper focuses on the All-SAT (ALL-SATisfiable) problem, which aims to compute all satisfiable assignment of a propositional formula, and presents an efficient solver \tool to help tackle such problems.

Although the satisfiability of propositional formulas is known as a NP-complete problem, modern SAT solvers are able to find a satisfiable assignment within affordable time. However, directly enumerating all satisfiable assignments of a formula may be infeasible because the number of such assignments can be exponential to the size of the formula. As a result, solving the All-SAT problem remains as a challenging task. As far as we know, there are mainly two kinds of solutions to All-SAT, i.e., the blocking-based~\cite{mcmillan2002applying} and non-blocking-based~\cite{grumberg2004memory}. The blocking-based strategy uses the SAT solver to find a satisfiable assignment, and then blocks such assignment in the original formula so as to avoid finding the same solution repeatedly. Blocking partial assignments instead of the full ones is a common optimization used in the blocking-based solution. The motivation comes from that normally the SAT solver is good at enumerating partial assignments while not at the full ones. 
Meanwhile, the non-blocking solution backtracks the decision diagram inside the SAT solver to find every satisfiable assignment of the given formula. Once a (full) satisfiable assignment is found by the SAT solver, the non-blocking approach backtracks to a previous decision level with some specific strategies and flips the value of the decision variable at that level to generate a new assignment. The All-SAT computation is complete as soon as every branch value of variables in the decision diagram is visited. 
The advantages of the non-blocking strategy are to avoid the changes of the formula and utilizes the full information of the decision diagrams in the SAT solver, while the blocking-based one is more straightforward and the implementation does not require changes to the SAT solver.

\tool follows the blocking-based framework, uses Minisat v2.1.1~\cite{minisat} as the underlying SAT solver and is implemented in C++. The distinguished feature of \tool is to use the backbone information to reduce the sizes of partial assignments and thus the corresponding blocking clauses. It is not hard to prove that removing every backbone variable from the partial assignment and adding it back to the given formula as a unit clause does not affect the satisfying assignment space of the original formula. 
However, the benefit of doing so is, the number of SAT solving in \tool may be reduced as a shorter partial assignment potentially represents a set of more full ones. As a result, the performance of \tool may improve significantly. Although finding backbone variables pays additional cost, \tool performs better than the state-of-the-art tools.

We compared \tool to 4 off-the-shelf solvers, including two blocking-based, i.e., \ctool~\cite{ctool} and \bc, and two non-blocking-based, i.e., \nbc and \bdd~\cite{ietool}. Among all the testing solvers, \tool solves (finds every assignment of the given formula) the largest amount of formulas (79 out of 608) within the given time and memory resources, comparing to the number of 65, 64, 53 and 50 for \ctool, \bc, \nbc and \bdd  respectively. 
For the 31 formulas that can be solved by all the solvers, \tool performs the fastest by saving the percentage of 51\%, 48\%, 54\% and 67\% time cost than \ctool, \bc, \nbc and \bdd respectively.
%For the formulas that are solved by both \tool and \ctool, \tool uses 23\% less computing time than \ctool does.
%\tool uses 37\%, 68\% and 31\% less computing time than \bc, \nbc and \bdd does respectively for the formulas that are mutually solved by \tool and one of the comparing tools.
Finally, \tool uses the minimal blocking clauses among the three blocking-based tools. The average length of blocking clauses in \tool is 1026, which is approximately 5\% of that in \ctool (22182) and 16\% of that in \bc (6180). 

The remainder of the paper is organized as follows. We describe notations and preliminaries in Section \ref{sec:prel}. The algorithms of \tool are discussed in Section \ref{sec:meth}, experimental results are shown in Section \ref{sec:expr} and related work are discussed in Section \ref{sec:rela}. We conclude the paper in Section \ref{sec:conc}.

