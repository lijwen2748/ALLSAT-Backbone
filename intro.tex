\section{Introduction}
The SAT (SATisfiable) applications, such as model checking~\cite{bmc,ic3}, program analysis~\cite{klee,cpachecker,cbmc}, network verification ~\cite{lopes2015checking,majumdar2014kuai,zhang2012verification}, quantifier elimination~\cite{brauer2011existential} and predicate abstraction~\cite{lahiri2003symbolic}, have gained considerable attentions due to the increasing capability of modern SAT solvers. 
Also, among several applications like unbounded hardware model checking ~\cite{car}, logic minimization ~\cite{sapra2003sat}, and temporal logic planning ~\cite{aalta}, computing all satisfiable assignments of the model is demanded. This paper focuses on the All-SAT (ALL-SATisfiable) problem, which aims to compute all satisfiable assignment of a propositional formula, and presents an efficient solver \tool to help tackle such problems.

Although the satisfiability of propositional formulas is known as a NP-complete problem, modern SAT solvers are able to find a satisfiable assignment within affordable time. However, directly enumerating all satisfiable assignments of a formula may be infeasible because the number of such assignments can be exponential to the size of the formula. As a result, solving the All-SAT problem remains as a challenging task. As far as we know, there are mainly two kinds of solutions to All-SAT, i.e., the blocking-based~\cite{mcmillan2002applying} and non-blocking-based~\cite{grumberg2004memory}. The blocking-based strategy uses the SAT solver to find a satisfiable assignment, and then blocks such assignment in the original formula so as to avoid finding the same solution repeatedly. Blocking partial assignments instead of the full ones is a common optimization used in the blocking-based solution. The motivation comes from that normally the SAT solver is good at enumerating partial assignments while not at the full ones. 
Meanwhile, the non-blocking solution backtracks the decision diagram inside the SAT solver to find every satisfiable assignment of the given formula. Once a (full) satisfiable assignment is found by the SAT solver, the non-blocking approach backtracks to a previous decision level with some specific strategies and flip the value of the decision variable at that level to generate a new assignment. The All-SAT computation is complete as soon as every branch value of variables in the decision diagram is visited. 
The advantages of the non-blocking strategy are to avoid the changes of the formula and utilizes the full information of the decision diagrams in the SAT solver, while the blocking-based one is more straightforward and the implementation does not require changes to the SAT solver.

The All-SAT solver \tool we introduced is a blocking based solver, we use Minisat v2.1.1~\cite{minisat} as the underlying SAT solver and implemented \tool with C++. The main innovation of \tool is that it uses the backbone information to reduce the length of the partial assignments and the corresponding blocking clauses. By removing every backbone variable from the partial assignment and adding them back to the given formula as unit clauses, the correctness of the partial assignment remains the same.
The number of SAT solving in \tool is reduced since every single shorter partial solution represents more full solutions. And the efficiency of \tool increases. Although finding backbone variables pays additional cost, the efficiency of \tool is still faster than the state-of-the-art tool~\cite{ctool} (\ctool).

We compared \tool with 4 other tools, including 2 blocking based tools, \ctool~\cite{ctool} and \bc, one non-blocking based tool , \nbc and one BDD-based tool, \bdd~\cite{ietool}. Among the 5 tools, \tool solves (finds every solution of the given formulas) the most formulas (79) within the given time and memory limitation, while the number of solved formulas for \ctool, \bc, \nbc and \bdd  are 65, 64, 53 and 50 respectively. 
For the formulas that are solved by both \tool and \ctool, \tool uses 23\% less computing time than \ctool does.
\tool uses 37\%, 68\% and 31\% less computing time than \bc, \nbc and \bdd does respectively for the formulas that are mutually solved by \tool and one of the comparing tools.
\tool also uses the shortest blocking clauses among the three blocking based tools, the average length of blocking clauses for \tool is 1026, which is 20 times less than \ctool (22182) and 84\% less than \bc (6180). 

The remainder of the paper is organized as follows. We describe notations and preliminaries in Section \ref{sec:prel}. The algorithms of \tool are discussed in Section \ref{sec:meth}, experimental results are shown in Section \ref{sec:expr} and related work are discussed in Section \ref{sec:rela}. We conclude the paper in Section \ref{sec:conc}.

